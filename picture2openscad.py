"""
picture2openscad.py
Maintained by Jerry Jia <mailto:jiazhen.thinpig@gmail.com>

This is a class that will be used for OpenSCAD 3D object code generation from a 2D picture.
It will support different function for some quick 3D modelling from 2D object.

v1.3 (03/19/2020) changes from v1.2
- support ScatterCube, ScatterSphere for scatter
- support ScatterChart to generate chart from a 14-D list, and support index text

v1.2 (03/12/2020) changes from v1.1
- support color picture import and color cube

v1.1 (03/12/2020) changes from v1.0
- optimize func return
- separate output file into func ExportScad()
- remove ColorCode from func PixelCubeZDepth parameter
- add func ModelMirror, func ModelTranslate, func ModelScale, func ModelColor

v1.0 (03/11/2020)
- basic picture2opdensca


Use:

import picture2openscad

debug_mode = False
picture_filename = "example//Mount_Fuji.png"

pic2scad = picture2openscad.picture2openscad()
im = pic2scad.ImportPicture(picture_filename, picture_color_space = "GRAY", picture_color_invert= True, picture_flip= "HORI",picture_norm_type="NORM_MINMAX" )
pic2scad.PixelCubeZDepth(im, offset=[0,0,0], translate = [1,1,0], pixelcube = [1,1,1], zdepth = 10, exclude_threshold = [-1,-1,-1], color_mode="GRAY", color_alpha=1)
pic2scad.ModelUnion()


"""

import cv2 
import numpy as np
from itertools import islice 


class picture2openscad(object):
    """This is a class that will be used for OpenSCAD 3D object code generation from a 2D picture.
    
    """
    def __init__(self, debug_mode=None):
        """
        Class constructor.
        picture_x_limit, x limitation, default 500
        picture_y_limit, y limitation, default 500
        picture_limit_scale , auto scale if size larger than limitation, default False

        Inputs:
            optional:
                debug mode - 1 if we want huge debug spew
        Return:
            Remote Agent handle
        """
        if debug_mode:
            self.debug_mode = 1
        else:
            self.debug_mode = 0

        self.picture_x_limit = 500
        self.picture_y_limit = 500
        self.picture_limit_scale = False

        self.scad_script_content = []
        self.scad_output_sign = '// This is OpenSCAD script generated by picture2openscad tool v1.3. \n// Please do not remove sign and check more information from https://github.com/JerryJiaGit/picture2openscad.py \n'
        #self.binary_threshold = 0


    def EnableDebug(self):
        """Externally callable function to enable debug mode.
        """
        self.debug_mode = 1

    def DisableDebug(self):
        """Externally callable function to disable debug mode.
        """
        self.debug_mode = 0

    def ExportScad(self, scad_filename = "output.scad"):
        """Export OpenScad output file name
        
        Keyword Arguments:
            scad_filename {str} -- (default: {"output.scad"})
        """

        with open(scad_filename, "w") as scad_output:
            scad_output.seek(0, 0)
            scad_output.write(self.scad_output_sign)
            for script_line in self.scad_script_content:
                scad_output.write(script_line + '\n')
        
        return

    def ImportPicture(self,picture_filename, picture_color_space="GRAY",picture_color_invert=True, picture_flip= "NONE",picture_norm_type="NORM_MINMAX" ):
        """This function will import image from picture_filename, support common picture format.

        Keyword Arguments:
            picture filename
            picture_color_space , color space of picture, default "GRAY", can be "BGR"
            picture_color_invert , invert gray, default True
            picture_flip = NONE , do picture flip default NONE disable, set to VERT -> vertical, HORI -> horizontal, VERT_HORI -> vertical and horizontal
            picture_norm_type="NORM_MINMAX" , do picture normalization default NORM_MINMAX, NORM_INF, NORM_L1, NORM_L2

        Output: image object in gray range[0:1]
        """
        try:
            im = cv2.imread(picture_filename)
        except:
            if self.debug_mode: print("Error: ImportPicture error with opening file " + inputfilename)
            return
        
        InputPicture_shape = im.shape 

        if InputPicture_shape[0] > self.picture_y_limit or InputPicture_shape[1] > self.picture_x_limit:
            if self.debug_mode: print("Warning: ImportPicture size is larger than limit " + str(self.picture_x_limit) +"," + str(self.picture_y_limit) + ",auto scale is " + str(self.picture_limit_scable))
            if self.picture_limit_scale:
                if InputPicture_shape[0] < InputPicture_shape[1]:
                    cv2.resize(src=im, dst=im, dsize=[self.picture_x_limit, self.picture_x_limit/InputPicture_shape[1]*InputPicture_shape[0]], interpolation=cv2.INTER_AREA)
                if InputPicture_shape[0] > InputPicture_shape[1]:
                    cv2.resize(src=im, dst=im, dsize=[self.picture_y_limit/InputPicture_shape[0]*InputPicture_shape[1], self.picture_u_limit], interpolation=cv2.INTER_AREA)
        
        ScaleInputPicture_shape = im.shape
        
        # picture color space convert
        if len(ScaleInputPicture_shape)==3 and picture_color_space == "GRAY": 
            if ScaleInputPicture_shape[2]==3: im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)

        # flip
        if picture_flip == "VERT": im = cv2.flip(im,0) # flip
        if picture_flip == "HORI": im = cv2.flip(im,1) # flip
        if picture_flip == "VERT_HORI": im = cv2.flip(im,-1) # flip

        # invert
        if picture_color_invert: im = abs(im-255) # gray invert

        im = np.float32(im)

        # scale and shift by NORM_MINMAX
        if picture_norm_type == "NORM_MINMAX":
            cv2.normalize(im, dst=im, alpha=0, beta=1.0, norm_type=cv2.NORM_MINMAX)
            if self.debug_mode:cv2.imshow("NORM_MINMAX", np.uint8(im*255))

        # scale and shift by NORM_INF
        if picture_norm_type == "NORM_INF":
            cv2.normalize(im, dst=im, alpha=1.0, beta=0, norm_type=cv2.NORM_INF)
            if self.debug_mode:cv2.imshow("NORM_INF", np.uint8(im*255))

        # scale and shift by NORM_L1
        if picture_norm_type == "NORM_L1":
            cv2.normalize(im, dst=im, alpha=1.0, beta=0, norm_type=cv2.NORM_L1)
            if self.debug_mode:cv2.imshow("NORM_L1", np.uint8(im*10000000))

        # scale and shift by NORM_L2
        if picture_norm_type == "NORM_L2":
            cv2.normalize(im, dst=im, alpha=1.0, beta=0, norm_type=cv2.NORM_L2)
            if self.debug_mode:cv2.imshow("NORM_L2", np.uint8(im*10000))

        if self.debug_mode:
            cv2.waitKey(0)
            cv2.destroyAllWindows()

        return im

    def ScatterCube(self, shape= [1,1,1], translate = [0,0,0], rotation = [0,0,0],  colorcode=[0.3,0.3,0.3,0.8], indextext = None):
        """This function will create a scatter cube with different size, translate, rotation, colors - 13-D
        
        Keyword Arguments:
            dimensions {[type]} -- [description] (default: {None})
            shape {list} -- [description] (default: {[1,1,1]})
            translate {list} -- [description] (default: {[0,0,0]})
            rotation {list} -- [description] (default: {[0,0,0]})
            colorcode {list} -- [description] (default: {[0.3,0.3,0.3,0.8]})
            indextext {type} -- [] (default: {None})
        """
        scad_script_color = "color(c=["+ str(colorcode[0]) +","+ str(colorcode[1]) +","+ str(colorcode[2])+","+ str(colorcode[3])+"])"
        self.scad_script_content.append(scad_script_color)
        scad_script_rotate = "rotate(a=["+ str(rotation[0]) +","+ str(rotation[1]) +","+ str(rotation[2])+"])"
        self.scad_script_content.append(scad_script_rotate)
        scad_script_translate = "translate([" + str(translate[0]) + "," + str(translate[1]) + ","+str(translate[2])+"])"
        self.scad_script_content.append(scad_script_translate)
        scad_script_pix2cube = "cube(["+str(shape[0])+","+str(shape[1])+","+str(shape[2])+"],center = false);"
        self.scad_script_content.append(scad_script_pix2cube)

        if indextext is not None:
            scad_script_text = 'text("' + str(indextext) + '", size = 0.1, font = "Liberation Sans:style=Bold Italic");'
            scad_script_linear_extrude = "linear_extrude(height=0.01)"
            scad_script_translate = "translate([" + str(translate[0]) + "," + str(translate[1]) + ","+str(translate[2]-0.1)+"])"
            scad_script_rotate = "rotate(a=["+ str(90) +","+ str(0) +","+ str(0)+"])"
            scad_script_linear_extrude = "linear_extrude(height=0.01)"
            scad_script_color = "color(c=["+ str(.1) +","+ str(.1) +","+ str(.1)+","+ str(.6)+"])"
            self.scad_script_content.append(scad_script_color+scad_script_translate+scad_script_rotate+scad_script_linear_extrude+scad_script_text)


        return self.scad_script_content

    def ScatterSphere(self, shape= [1,1,1], translate = [0,0,0], rotation = [0,0,0],  colorcode=[0.3,0.3,0.3,0.8], indextext = None):
        """This function will create a scatter cube with different size, translate, rotation, colors - 13-D
        
        Keyword Arguments:
            size {list} -- [size[0] is Diameter and size[1] is a full circle rendered using this number of fragments] (default: {[1,12]})
            translate {list} -- [description] (default: {[0,0,0]})
            rotation {list} -- [description] (default: {[0,0,0]})
            colorcode {list} -- [description] (default: {[0.3,0.3,0.3,0.8]})
            indextext {type} -- [] (default: {None})
        
        Returns:
            [type] -- [description]
        """
        scad_script_color = "color(c=["+ str(colorcode[0]) +","+ str(colorcode[1]) +","+ str(colorcode[2])+","+ str(colorcode[3])+"])"
        self.scad_script_content.append(scad_script_color)
        scad_script_rotate = "rotate(a=["+ str(rotation[0]) +","+ str(rotation[1]) +","+ str(rotation[2])+"])"
        self.scad_script_content.append(scad_script_rotate)
        scad_script_translate = "translate([" + str(translate[0]) + "," + str(translate[1]) + ","+str(translate[2])+"])"
        self.scad_script_content.append(scad_script_translate)
        scad_script_pix2sphere = "sphere(d="+str(shape[0])+",$fa="+str(shape[1])+",$fs="+str(shape[2])+",$fn=0);"
        self.scad_script_content.append(scad_script_pix2sphere)

        if indextext is not None:
            scad_script_text = 'text("' + str(indextext) + '", size = 0.1, font = "Liberation Sans:style=Bold Italic");'
            scad_script_linear_extrude = "linear_extrude(height=0.01)"
            scad_script_translate = "translate([" + str(translate[0]) + "," + str(translate[1]) + ","+str(translate[2]-0.1)+"])"
            scad_script_rotate = "rotate(a=["+ str(90) +","+ str(0) +","+ str(0)+"])"
            scad_script_linear_extrude = "linear_extrude(height=0.01)"
            scad_script_color = "color(c=["+ str(.1) +","+ str(.1) +","+ str(.1)+","+ str(.6)+"])"
            self.scad_script_content.append(scad_script_color+scad_script_translate+scad_script_rotate+scad_script_linear_extrude+scad_script_text)

        return self.scad_script_content

    def ScatterChart(self, dimensions, index=False):
        """This function will create a scatter chart
        
        Arguments:
            dimensions {[type]} -- [description]
            index {bool} -- [] (default: {False})
        """
        

        if len(dimensions[0])==14:
            length_split = [1, 3, 3, 3,4]
            i = 0
            for scatter in dimensions:
                
                if index: i += 1
                else: i = None
                scatter = iter(scatter) 
                splitlist = [list(islice(scatter, elem)) for elem in length_split]
                if splitlist[0][0] == 1:
                    self.ScatterCube(shape= splitlist[1], translate = splitlist[2], rotation = splitlist[3],  colorcode=splitlist[4], indextext = i)
                elif splitlist[0][0] == 2:
                    self.ScatterSphere(shape= splitlist[1], translate = splitlist[2], rotation = splitlist[3],  colorcode=splitlist[4], indextext = i)
                else:
                    return self.scad_script_content
                
        return self.scad_script_content

    def PixelCubeZDepth(self, im_src, offset=[0,0,0], translate = [1,1,0], pixelcube = [.2,.2,.2], zdepth = 5, exclude_threshold = [0], color_mode="GRAY", color_alpha=1):
        """This function will create cube based image from ImportPicture()
        Keyword Arguments:
            im_src
            offset=[0,0,0]           ,final pixel location offset
            translate = [1,1,0]      ,final pixel cube scale, z=0 means cube z will depends on ZDepth, otherwise z location will be controlled by picture color
            pixelcube = [.2,.2,.2]   ,pixel cube size
            zdepth = 5               ,zdepth will control cube z length, zdepth=0 meas cube z depth will not controlled by picture color
            exclude_threshold = [0,0,0]    ,color excluded to build cube, default is 0
            color_mode="GRAY"        ,color mode, GRAY means will color cube based on picture color
            

        Output: self.scad_script_content {list}
        """
        pixel_index = 0
        Y = 0
        #print(np.array(im_src[100][150]))
        for y in range(0,im_src.shape[0]):
            for x in range(0,im_src.shape[1]):
                if not np.array_equal(np.array(im_src[y][x]),np.array(exclude_threshold)):  # exclude_threshold
                    if color_mode == "GRAY": 
                        if len(im_src.shape)==3: 
                            if im_src.shape[2]==3: 
                                Y=0.299 * im_src[y][x][2] + 0.587 * im_src[y][x][1] + 0.114 * im_src[y][x][0]
                                r,g,b=Y,Y,Y
                                a=color_alpha
                            if im_src.shape[2]==1:
                                Y=im_src[y][x]
                                r,g,b=Y,Y,Y
                                a=color_alpha
                        if len(im_src.shape)==2: 
                            Y=im_src[y][x]
                            r,g,b=Y,Y,Y
                            a=color_alpha
                        scad_script_color = "color( c = ["+str(abs(r))+","+str(abs(g))+","+str(abs(b))+","+str(abs(a))+"])"
                        self.scad_script_content.append(scad_script_color)
                    if color_mode == "BGR":
                        if len(im_src.shape)==3: 
                            if im_src.shape[2]==3: 
                                Y=0.299 * im_src[y][x][2] + 0.587 * im_src[y][x][1] + 0.114 * im_src[y][x][0]
                                b,g,r=im_src[y][x]
                                a=color_alpha
                            if im_src.shape[2]==1:
                                Y=im_src[y][x]
                                r,g,b=Y,Y,Y
                                a=color_alpha
                        if len(im_src.shape)==2: 
                            Y=im_src[y][x]
                            r,g,b=Y,Y,Y
                            a=color_alpha
                        scad_script_color = "color( c = ["+str(abs(r))+","+str(abs(g))+","+str(abs(b))+","+str(abs(a))+"])"
                        self.scad_script_content.append(scad_script_color)
                    if color_mode == "BGRA":
                        if len(im_src.shape)==3: 
                            if im_src.shape[2]==4:
                                Y=0.299 * im_src[y][x][2] + 0.587 * im_src[y][x][1] + 0.114 * im_src[y][x][0]
                                b,g,r,a=im_src[y][x]
                        scad_script_color = "color( c = ["+str(abs(r))+","+str(abs(g))+","+str(abs(b))+","+str(abs(a))+"])"
                        self.scad_script_content.append(scad_script_color)

                    translate_x = x * translate[0] + offset[0]
                    translate_y = y * translate[1] + offset[1]
                    translate_z = (1-Y)*translate[2] + offset[2]
                    cube_x = pixelcube[0]
                    cube_y = pixelcube[1]
                    if zdepth == 0: cube_z = pixelcube[2]
                    else: cube_z = pixelcube[2]*(1-Y) * zdepth

                    scad_script_translate = "translate([" + str(translate_x) + "," + str(translate_y) + ","+str(translate_z)+"])"
                    self.scad_script_content.append(scad_script_translate)
                    scad_script_pix2cube = "cube(["+str(cube_x)+","+str(cube_y)+","+str(cube_z)+"],center = false);"
                    self.scad_script_content.append(scad_script_pix2cube)
                pixel_index = pixel_index + 1
        return self.scad_script_content

    def ModelUnion(self, script_content = ""):
        """This function will add union for OpenScad models at first line.

        Keyword Arguments:
            script_content {list}, default: self.scad_script_content

        Output: self.scad_script_content {list}
        """
        if script_content == "": script_content = self.scad_script_content
        UnionCode = "union(){"
        script_content.insert(0, UnionCode)
        script_content.append("}")
        self.scad_script_content = script_content
        return self.scad_script_content

    def ModelRotate(self, script_content = "", rotate_a=[0,0,0]):
        """This function will add rotate for OpenScad models at first line.

        Keyword Arguments:
            rotate_a       {list}, default: [0,0,0]
            script_content {list}, default: self.scad_script_content


        Output: self.scad_script_content {list}
        """
        if script_content == "": script_content = self.scad_script_content
        RotateCode = "rotate(a=["+ str(rotate_a[0]) +","+ str(rotate_a[1]) +","+ str(rotate_a[2])+"]){"
        script_content.insert(0, RotateCode)
        script_content.append("}")
        self.scad_script_content = script_content
        return self.scad_script_content


    def ModelScale(self, script_content = "", scale_v=[1,1,1]):
        """This function will add scale for OpenScad models at first line.

        Keyword Arguments:
            scale_v        {list}, default: [1,1,1]
            script_content {list}, default: self.scad_script_content


        Output: self.scad_script_content {list}
        """
        if script_content == "": script_content = self.scad_script_content
        ScaleCode = "scale(v=["+ str(scale_v[0]) +","+ str(scale_v[1]) +","+ str(scale_v[2])+"]){"
        script_content.insert(0, ScaleCode)
        script_content.append("}")
        self.scad_script_content = script_content
        return self.scad_script_content

    # def ModelResize(self, script_content = "", resize_newsize=[1,1,1]):
    #     """This function will add scale for OpenScad models at first line.

    #     Keyword Arguments:
    #         resize_newsize {list}, default: [1,1,1]
    #         script_content {list}, default: self.scad_script_content


    #     Output: self.scad_script_content {list}
    #     """
    #     if script_content == "": script_content = self.scad_script_content
    #     ResizeCode = "resize(newsize=["+ str(resize_newsize[0]) +","+ str(resize_newsize[1]) +","+ str(resize_newsize[2])+"]){"
    #     script_content.insert(0, ResizeCode)
    #     script_content.append("}")
    #     self.scad_script_content = script_content
    #     return self.scad_script_content

    def ModelTranslate(self, script_content = "", translate_v=[1,1,1]):
        """This function will add scale for OpenScad models at first line.

        Keyword Arguments:
            translate_v    {list}, default: [1,1,1]
            script_content {list}, default: self.scad_script_content


        Output: self.scad_script_content {list}
        """
        if script_content == "": script_content = self.scad_script_content
        TranslateCode = "translate(v=["+ str(translate_v[0]) +","+ str(translate_v[1]) +","+ str(translate_v[2])+"]){"
        script_content.insert(0, TranslateCode)
        script_content.append("}")
        self.scad_script_content = script_content
        return self.scad_script_content

    def ModelMirror(self, script_content = "", mirror_v=[1,1,1]):
        """This function will add scale for OpenScad models at first line.

        Keyword Arguments:
            mirror_v       {list}, default: [1,1,1]
            script_content {list}, default: self.scad_script_content


        Output: self.scad_script_content {list}
        """
        if script_content == "": script_content = self.scad_script_content
        MirrorCode = "mirror(v=["+ str(mirror_v[0]) +","+ str(mirror_v[1]) +","+ str(mirror_v[2])+"]){"
        script_content.insert(0, MirrorCode)
        script_content.append("}")
        self.scad_script_content = script_content
        return self.scad_script_content

    def ModelColor(self, script_content = "", color_c=[.2,1,0.2,0.2]):
        """This function will add scale for OpenScad models at first line.

        Keyword Arguments:
            color_c        {list}, if color mode is not GRAY, you can customize cube color [r,g,b,a], default: [.2,1,0.2,0.2]
            script_content {list}, default: self.scad_script_content


        Output: self.scad_script_content {list}
        """
        if script_content == "": script_content = self.scad_script_content
        ColorCode = "color(c=["+ str(color_c[0]) +","+ str(color_c[1]) +","+ str(color_c[2])+","+ str(color_c[3])+"]){"
        script_content.insert(0, ColorCode)
        script_content.append("}")
        self.scad_script_content = script_content
        return self.scad_script_content